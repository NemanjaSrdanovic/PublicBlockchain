package blockchain.wallet.model;

import java.security.Signature;
import java.util.HashMap;
import java.util.LinkedHashMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import blockchain.block.Transaction;
import blockchain.concensus.SHA256Hasher;
import blockchain.wallet.helper.KeyGenerator;

/**
 * This wallet object is used to store the private and public key generated by
 * the KeyGenerator object and sign a new transaction before broadcasting it to
 * the network.
 * 
 * @author Nemanja Srdanovic
 * @version 1.0
 * @since 10 Dec 2021
 */
public class Wallet {

	private static Logger logger = LoggerFactory.getLogger(Wallet.class);
	private String hexStringPublicKey;
	private double balance;
	private double pendingTransactionsAmount;
	private KeyGenerator keyGenerator;
	private String walletAddress;
	private HashMap<String, Transaction> walletPendingTransaction;

	/**
	 * Instantiates a new Wallet object which instantiates a new KeyGenerator object
	 * that automatically generates the public and private key. The hex string
	 * representation of the public key is than again hashed to create a unique
	 * wallet address.
	 */
	public Wallet() {
		super();

		this.keyGenerator = new KeyGenerator();
		this.hexStringPublicKey = keyGenerator.getHexStringPublicKey();
		this.walletAddress = SHA256Hasher.returnSHA256HashStringFromString(hexStringPublicKey);
		this.walletPendingTransaction = new LinkedHashMap<String, Transaction>();

		logger.info("Wallet address: " + walletAddress);

	}

	/**
	 * Returns the public key of this wallet object as a string in a hex form.
	 * 
	 * @return
	 */
	public String getHexStringPublicKey() {
		return hexStringPublicKey;
	}

	/**
	 * Returns the KeyGenerator object which produces the public and private key.
	 * 
	 * @return
	 */
	public KeyGenerator getKeyGenerator() {
		return keyGenerator;
	}

	/**
	 * Returns the wallet address as a string in a hex form.
	 * 
	 * @return
	 */
	public String getWalletAddress() {
		return walletAddress;
	}

	/**
	 * This method is using the private key of this wallet object to sign the
	 * transaction id of a transaction and return a signature string.
	 * 
	 * @param transactionID
	 * @return
	 */
	public String signTransaction(String transactionID) {

		byte[] signedTransactionID = null;
		try {
			Signature signature = Signature.getInstance("SHA256withECDSA", "SunEC");
			signature.initSign(keyGenerator.getPrivateKey());
			byte[] stringToSign = transactionID.getBytes("UTF-8");
			signature.update(stringToSign);
			signedTransactionID = signature.sign();

		} catch (Exception e) {

			logger.error("Signature initialization exception.", e);

		}

		if (signedTransactionID != null)
			return keyGenerator.byteArrayToHexString(signedTransactionID);
		else
			throw new RuntimeException("Transaction id was not signed.");

	}

	public double getBalance() {
		return balance - getPendingTransactionsAmount();
	}

	public void setBalance(double balance) {
		this.balance = balance;
	}

	public HashMap<String, Transaction> getWalletPendingTransaction() {
		return walletPendingTransaction;
	}

	public double getPendingTransactionsAmount() {
		return pendingTransactionsAmount;
	}

	public void setPendingTransactionsAmount(double pendingTransactionsAmount) {
		this.pendingTransactionsAmount = pendingTransactionsAmount;
	}

}