package blockchain.wallet.helper;

import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.ECGenParameterSpec;
import java.security.spec.X509EncodedKeySpec;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 
 * This KeyGenerator object is used to create the public and private key for a
 * wallet object, as well as transforming those keys into strings in hex format,
 * byte array and vice versa. The functions that this object uses are part of
 * the java.security library and are set up as specified in that library. The
 * functions for transforming the keys are also standard functions specified in
 * the links below.
 * 
 * 
 * @see https://etzold.medium.com/elliptic-curve-signatures-and-how-to-use-them-in-your-java-application-b88825f8e926
 *      https://www.geeksforgeeks.org/java-program-to-convert-hex-string-to-byte-array/?ref=gcse
 *      https://www.geeksforgeeks.org/java-program-to-convert-byte-array-to-hex-string/
 *      https://docs.oracle.com/javase/tutorial/security/apisign/vstep2.html
 * 
 * 
 * @author Nemanja Srdanovic
 * @version 1.0
 * @since 28 Nov 2021
 */
public class KeyGenerator {

	private static Logger logger = LoggerFactory.getLogger(KeyGenerator.class);
	private KeyPairGenerator generator;
	private ECGenParameterSpec ecsp;
	private KeyPair keyPair;
	private PrivateKey privateKey;
	private PublicKey publicKey;

	/**
	 * Instantiates a new KeyGenerator object.
	 */
	public KeyGenerator() {
		super();
		generateNewKeyPair();

	}

	/**
	 * This method generates a new key pair (public and private key) by using the
	 * Secp256k1 elliptic curve and saves the private and public keys in this
	 * KeyGenerator object.
	 */
	private void generateNewKeyPair() {

		try {
			generator = KeyPairGenerator.getInstance("EC", "SunEC");
			ecsp = new ECGenParameterSpec("secp256k1");
			generator.initialize(ecsp);
			this.keyPair = generator.genKeyPair();
			this.publicKey = this.keyPair.getPublic();
			this.privateKey = this.keyPair.getPrivate();

		} catch (Exception e) {
			logger.error("Key pair generation exception.", e);
		}

	}

	/**
	 * Returns the public key generated by this object in as a string in hex form.
	 * 
	 * @return
	 */
	public String getHexStringPublicKey() {

		return byteArrayToHexString(this.publicKey.getEncoded());

	}

	/**
	 * Returns the private key generated by this KeyGenerator object.
	 * 
	 * @return
	 */
	public PrivateKey getPrivateKey() {
		return privateKey;
	}

	/**
	 * Transforms a byte array to a string in hex form. This method can be used to
	 * transform the keys which can be streames as byte arrays.
	 * 
	 * @param byteArray
	 * @return
	 */
	public String byteArrayToHexString(byte[] byteArray) {
		String hex = "";

		for (byte i : byteArray) {
			hex += String.format("%02X", i);
		}

		return hex.toLowerCase();
	}

	/**
	 * Transforms a string in hex form to a byte array. This method can be used to
	 * transform the keys back to the byte array which can be transformed to the
	 * Public/PrivateKey object.
	 * 
	 * @param hexString
	 * @return
	 */
	@SuppressWarnings("unused")
	private byte[] hexStringToByteArray(String hexString) {

		byte[] ans = new byte[hexString.length() / 2];

		for (int i = 0; i < ans.length; i++) {
			int index = i * 2;

			int val = Integer.parseInt(hexString.substring(index, index + 2), 16);
			ans[i] = (byte) val;
		}

		return ans;

	}

	/**
	 * Transforms a byte array into a public key by using standard methods defined
	 * in the java.security library.
	 * 
	 * @param encodedKey
	 * @return
	 * @throws Exception
	 */
	@SuppressWarnings("unused")
	private PublicKey byteArrayToPublicKey(byte[] encodedKey) throws Exception {
		KeyFactory factory = KeyFactory.getInstance("EC", "SunEC");
		X509EncodedKeySpec encodedKeySpec = new X509EncodedKeySpec(encodedKey);
		return factory.generatePublic(encodedKeySpec);
	}

}
